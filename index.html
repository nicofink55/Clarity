<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Clarity">
<title>Clarity v7</title>
<style>
:root{--bg:#07070c;--panel:#0d0d18;--border:#1a1a2e;--neon:#00e5ff;--neon2:#7c4dff;--pink:#ff4081;--green:#00e676;--yellow:#fdd835;--red:#ff5252;--text:#c8ccd4;--dim:#556;--dark:#0a0a12;--font:'SF Mono','Menlo','Consolas',monospace}
*{box-sizing:border-box;margin:0;padding:0}
body{font-family:var(--font);background:var(--bg);color:var(--text);font-size:13px;max-width:540px;margin:0 auto;padding:8px;padding-top:env(safe-area-inset-top,8px);min-height:100vh;-webkit-text-size-adjust:none}
input,select,button{font-family:var(--font)}
input,select{width:100%;padding:10px;background:var(--dark);border:1px solid var(--border);border-radius:6px;color:var(--text);font-size:14px;outline:none}
input:focus{border-color:var(--neon)}
button{cursor:pointer;border:none;border-radius:6px;font-weight:600}
.hdr{text-align:center;padding:12px 0 6px;border-bottom:1px solid var(--border);margin-bottom:10px}
.hdr h1{font-size:20px;font-weight:800;color:var(--neon);letter-spacing:4px}
.hdr sub{font-size:9px;color:var(--dim)}
.card{background:var(--panel);border:1px solid var(--border);border-radius:8px;padding:12px;margin-bottom:8px}
.lbl{font-size:10px;color:var(--dim);text-transform:uppercase;letter-spacing:1px;margin-bottom:4px}
.row{display:flex;gap:8px;margin-bottom:8px}
.row>div{flex:1}
.btn1{width:100%;padding:14px;background:linear-gradient(135deg,#00e5ff18,#00e5ff08);border:1px solid #00e5ff55;color:var(--neon);font-size:14px;letter-spacing:2px}
.btn1:active{background:#00e5ff22}
.btn1:disabled{opacity:.4}
.st{font-size:10px;color:var(--dim);text-align:center;padding:4px 0}
.st.ok{color:var(--green)}.st.err{color:var(--pink)}
.vb{text-align:center;padding:16px;border-radius:8px;margin-bottom:8px}
.vt{font-size:24px;font-weight:800;letter-spacing:3px}
.vr{display:flex;justify-content:center;gap:24px;margin-top:10px}
.vc{text-align:center}.vc .l{font-size:9px;color:var(--dim)}.vc .v{font-size:18px;font-weight:700}
.tabs{display:flex;gap:2px;margin-bottom:8px}
.tabs button{flex:1;padding:8px;font-size:10px;text-transform:uppercase;letter-spacing:1px;background:transparent;border:1px solid transparent;color:var(--dim)}
.tabs button.act{background:var(--panel);border-color:#00e5ff33;color:var(--neon)}
.dr{display:flex;justify-content:space-between;padding:5px 0;border-bottom:1px solid var(--dark)}
.dr .k{color:var(--dim);font-size:11px}.dr .v{font-size:12px;font-weight:500}
.sr{display:flex;justify-content:space-between;align-items:center;padding:9px 0;border-bottom:1px solid #111}
.sr:last-child{border:none}
.log{font-size:10px;color:var(--dim);max-height:90px;overflow-y:auto;padding:6px;background:var(--dark);border-radius:4px;margin-top:6px;white-space:pre-wrap;word-break:break-all}
.chips{display:flex;flex-wrap:wrap;gap:4px;margin-top:6px}
.chip{padding:4px 10px;background:var(--dark);border:1px solid var(--border);border-radius:12px;color:var(--neon);font-size:11px;font-weight:600;cursor:pointer}
.chip:active{background:var(--border)}
.flag{font-size:10px;color:var(--yellow);margin-top:4px}
.hide{display:none}
</style>
</head>
<body>
<div class="hdr"><h1>CLARITY</h1><sub>SEC Filing &rarr; Probabilistic DCF &middot; v7</sub></div>
<div class="card">
 <div class="lbl">Ticker</div>
 <div class="row">
  <div style="flex:2"><input id="ticker" placeholder="AMZN" autocapitalize="characters" autocomplete="off" autocorrect="off" spellcheck="false"></div>
  <div style="flex:1"><select id="formType"><option value="10-K">10-K</option><option value="10-Q">10-Q</option></select></div>
 </div>
 <button class="btn1" id="pullBtn" onclick="pullFiling()">&#9166; PULL FROM EDGAR</button>
 
 <div class="row" style="margin-top:4px">
  <div style="flex:3"><input id="proxyUrl" placeholder="Custom proxy URL (optional)" value="" style="font-size:11px;padding:8px"></div>
 </div>
 <div class="chips" id="recents"></div>
 <div class="log" id="log"></div>
</div>
<div class="card">
 <div class="lbl">Or Load File</div>
 <input type="file" id="fileInput" accept=".htm,.html" onchange="handleFile(event)" style="font-size:12px;padding:8px;border:1px dashed var(--border)">
</div>
<div class="card hide" id="inputsCard">
 <div class="row">
  <div><div class="lbl">Price $</div><input id="price" type="number" step="0.01" placeholder="0.00"></div>
  <div><div class="lbl">Shares (M)</div><input id="shares" type="number" step="0.1" placeholder="0.0"></div>
 </div>
 <div class="lbl">Sector</div>
 <select id="sector"></select>
 <div style="height:8px"></div>
 <button class="btn1" onclick="runDCFUI()">RUN DCF &#9654;</button>
 <div class="st" id="parseStatus"></div>
</div>
<div id="results" class="hide">
 <div class="vb" id="verdictBanner">
  <div class="vt" id="verdictText"></div>
  <div class="vr">
   <div class="vc"><div class="l">Fair Value</div><div class="v" id="fvVal"></div></div>
   <div class="vc"><div class="l">Price</div><div class="v" id="priceVal" style="color:#999"></div></div>
   <div class="vc"><div class="l">Upside</div><div class="v" id="upVal"></div></div>
  </div>
  <div id="bbmFlag" class="hide" style="font-size:10px;color:var(--yellow);margin-top:6px">&#128260; Buyback Machine Detected</div>
 </div>
 <div class="tabs" id="tabBar">
  <button class="act" onclick="showTab('summary',this)">Summary</button>
  <button onclick="showTab('scenarios',this)">Scenarios</button>
  <button onclick="showTab('financials',this)">Financials</button>
 </div>
 <div id="tab-summary" class="card"></div>
 <div id="tab-scenarios" class="card hide"></div>
 <div id="tab-financials" class="card hide"></div>
</div>
<div style="text-align:center;padding:16px 0 8px;font-size:9px;color:#333">CLARITY v7 &middot; Full SEC Parser</div>
<script>

// â•â•â• ENGINE (from React artifact) â•â•â•


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CLARITY PWA â€” SEC Filing â†’ Probabilistic DCF Analyzer
// Full port of Python engine to client-side JavaScript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€ Number parsing â”€â”€
function cleanNum(text) {
  if (!text || typeof text !== "string") return null;
  text = text.trim();
  if (["â€”", "â€“", "-", "", "N/A", "*", "$", "N/M", ")", "("].includes(text)) return null;
  const isNeg = text.includes("(");
  let cleaned = text.replace(/[$,\s()]/g, "");
  cleaned = cleaned.replace(/%.*$/, "");
  cleaned = cleaned.replace(/[A-Za-z]+$/, "");
  if (!cleaned || ["â€”", "â€“", "-"].includes(cleaned)) return null;
  const val = parseFloat(cleaned);
  if (isNaN(val)) return null;
  return isNeg ? -val : val;
}

// â”€â”€ Scale detection (vote-based) â”€â”€
function detectScale(text) {
  const t = text.toLowerCase();
  const thou = (t.match(/in\s+thousands|in\s+\$\s*000|\(\s*thousands/g) || []).length;
  const mill = (t.match(/in\s+millions|\(\s*millions/g) || []).length;
  const bill = (t.match(/in\s+billions|\(\s*billions/g) || []).length;
  if (bill > 0 && bill >= thou && bill >= mill) return 1e9;
  if (thou > 0 && thou >= mill) return 1e3;
  if (mill > 0) return 1e6;
  if (/except\s+per[\s-]+share/i.test(t) || /except\s+share\s+data/i.test(t)) return 1e6;
  return 1000;
}

// â”€â”€ Form detection â”€â”€
function detectForm(fullText, filename) {
  const ft = fullText.toLowerCase();
  if (filename) {
    const fn = filename.toLowerCase();
    if (fn.includes("10-q") || fn.includes("10q")) return ["10-Q", true];
    if (fn.includes("20-f") || fn.includes("20f")) return ["20-F", false];
    if (fn.includes("10-k") || fn.includes("10k")) return ["10-K", false];
  }
  if (/\bq[1-3]\b/.test(ft.slice(0, 500))) return ["10-Q", true];
  const area = ft.slice(0, 30000);
  if (/\b10-q\b/.test(area) || /quarterly\s+report/.test(area)) return ["10-Q", true];
  if (/\b20-f\b/.test(area)) return ["20-F", false];
  if (/three\s+months?\s+ended/.test(ft)) return ["10-Q", true];
  return ["10-K", false];
}

// â”€â”€ Sector detection â”€â”€
var SECTOR_NAMES = {
  hyperscaler: "Mega-Cap / Hyperscaler", saas_tech: "SaaS / Tech / Cloud",
  pharma: "Pharma / Biotech", bank: "Bank", ep: "E&P (Oil & Gas)",
  midstream: "Midstream", utility: "Utility", consumer: "Consumer / Retail",
  industrial: "Industrial / Semis", fintech: "Fintech / Payments",
  insurance: "Insurance / Managed Care", telecom: "Telecom / Media", general: "General",
};

function detectSector(fullText) {
  const ft = fullText.toLowerCase();
  const rules = [
    [["net interest income","provision for credit loss","loan loss","tier 1 capital","net interest margin","deposits","allowance for loan"], "bank", 3],
    [["medical loss ratio","premiums earned","claims and benefits","underwriting income","policy liabilities","loss ratio","benefit ratio"], "insurance", 3],
    [["regulated utility","rate base","public utility","kilowatt","megawatt","rate case","electric utility","ratepayer"], "utility", 3],
    [["barrels of oil","crude oil production","natural gas production","proved reserves","exploration and production","boe/d","drilling"], "ep", 3],
    [["pipeline","gathering and processing","natural gas liquids","throughput","tariff rate","midstream"], "midstream", 3],
    [["clinical trial","fda approval","drug candidate","therapeutic area","phase 1","phase 2","phase 3","biologics"], "pharma", 2],
    [["wireless subscribers","postpaid","prepaid subscribers","spectrum","arpu","mobile subscribers"], "telecom", 3],
    [["subscription revenue","annual recurring revenue","saas","cloud-based platform","software-as-a-service","recurring revenue","net retention rate"], "saas_tech", 2],
    [["payment processing","transaction volume","gross payment volume","interchange","total payment volume","take rate","merchant"], "fintech", 2],
    [["same-store sales","comparable store sales","retail stores","consumer products","comp sales"], "consumer", 2],
    [["data center","cloud computing","hyperscal","cloud services","cloud revenue","ai infrastructure","gpu","datacenter"], "hyperscaler", 1.5],
    [["semiconductor","wafer","fabrication","backlog","defense contract","silicon carbide","photonics","laser"], "industrial", 1.5],
  ];
  const scores = {};
  for (const [kws, sector, weight] of rules) {
    let hits = 0;
    for (const kw of kws) {
      const re = new RegExp(kw.replace(/[-.*+?^${}()|[\]\\]/g, "\\$&"), "gi");
      const count = Math.min((ft.match(re) || []).length, 10);
      if (count > 0) hits += count;
    }
    if (hits) scores[sector] = (scores[sector] || 0) + hits * weight;
  }
  if (ft.includes("net interest income") && !ft.includes("subscription"))
    scores.bank = (scores.bank || 0) + 50;
  let best = "general", bestScore = 0;
  for (const [s, sc] of Object.entries(scores))
    if (sc > bestScore) { best = s; bestScore = sc; }
  return [best, bestScore > 20 ? "high" : bestScore >= 5 ? "medium" : "low"];
}

// â”€â”€ Labels for field extraction â”€â”€
var LABELS = {
  rev: ["total revenue","total revenues","net revenue","total net revenue","net sales","total net sales","revenues","total net revenues","net interest income","revenue"],
  ni: ["net income","net earnings","net income (loss)","net income attributable","net loss","net loss attributable"],
  oi: ["operating income","income from operations","operating profit","income / (loss) from operations","loss from operations"],
  gp: ["gross profit"],
  ta: ["total assets"],
  cash: ["cash and cash equivalents","cash and equivalents","cash, cash equivalents"],
  debt: ["long-term debt","long term debt","total long-term debt","senior notes","long-term borrowings","total debt"],
  tl: ["total liabilities"],
  eq: ["total stockholders","total shareholders","total equity","total stockholders' equity","total shareholders' equity","total shareowners' equity"],
  ocf: ["net cash provided by operating","net cash provided from operating","net cash from operating","cash provided by operating activities","net cash used in operating","net cash provided by (used in) operating","net cash provided from (used for) operating","cash flows from operating","net cash generated from operating","cash from operating activities","net cash flows provided by","net cash flows from operating"],
  capex: ["capital expenditure","purchases of property","purchase of property","additions to property","expenditures for property","purchases of property and equipment","acquisition of property","capital spending"],
  da: ["depreciation and amortization","depreciation"],
  shares_dil: ["diluted weighted average","weighted average common shares","shares used in computation","weighted-average shares used","diluted weighted average commo","weighted average number of shares","weighted-average diluted shares","weighted average diluted shares","total weighted-average diluted","average diluted shares","diluted shares outstanding","diluted average common"],
};

function findValue(rows, labels, colIdx = 0, exclude = null) {
  for (const row of rows) {
    if (!row) continue;
    const rowText = row.map(c => String(c || "")).join(" ").toLowerCase();
    if (exclude && exclude.some(x => rowText.includes(x))) continue;
    for (const label of labels) {
      if (rowText.includes(label.toLowerCase())) {
        const merged = [];
        let i = 0;
        while (i < row.length) {
          const s = String(row[i] || "").trim();
          if (s === "$" && i + 1 < row.length) {
            const nxt = String(row[i + 1] || "").trim();
            if (nxt && nxt !== "" && nxt !== "$") { merged.push("$" + nxt); i += 2; continue; }
          } else if (s === "(" && i + 1 < row.length) {
            merged.push("(" + String(row[i + 1] || "").trim()); i += 2; continue;
          }
          merged.push(s); i++;
        }
        const nums = merged.map(c => cleanNum(c)).filter(n => n !== null);
        if (nums.length > colIdx) return nums[colIdx];
      }
    }
  }
  return null;
}

function detectPeriod(table, fullText, is10q) {
  let hasThree = false, hasNine = false, hasSix = false, hasTwelve = false;
  const yearsFound = [];
  for (const row of table.slice(0, 5)) {
    const rt = row.map(c => String(c || "")).join(" ").toLowerCase();
    if (rt.includes("three month")) hasThree = true;
    if (rt.includes("nine month")) hasNine = true;
    if (rt.includes("six month")) hasSix = true;
    if (rt.includes("twelve month") || rt.includes("year ended")) hasTwelve = true;
    for (const c of row) {
      const cs = String(c || ""); const cl = cs.toLowerCase();
      if (["change","vs.","vs ","variance","growth"].some(x => cl.includes(x))) continue;
      const m = cs.match(/(20[1-3]\d)/);
      if (m) yearsFound.push(parseInt(m[1]));
    }
  }
  let numCols = 0;
  for (const row of table.slice(2, 8)) {
    const merged = []; let i = 0;
    while (i < row.length) {
      const s = String(row[i] || "").trim();
      if (s === "$" && i + 1 < row.length) { merged.push("$" + String(row[i+1]||"").trim()); i += 2; }
      else { merged.push(s); i++; }
    }
    const nc = merged.filter(c => cleanNum(c) !== null).length;
    if (nc > numCols) numCols = nc;
  }
  if (!is10q) {
    if (numCols >= 2 && yearsFound.length >= 2) {
      const maxYear = Math.max(...yearsFound);
      return [yearsFound.lastIndexOf(maxYear), 1];
    }
    return [0, 1];
  }
  if (hasTwelve && numCols >= 6) {
    if (yearsFound.length >= 6) return [yearsFound[yearsFound.length-1] >= yearsFound[yearsFound.length-2] ? yearsFound.length-1 : yearsFound.length-2, 1];
    return [numCols - 1, 1];
  }
  if (hasThree && (hasNine || hasSix)) {
    const ann = hasNine ? 4/3 : 2;
    if (yearsFound.length >= 4) return [yearsFound[2] >= yearsFound[3] ? 2 : 3, ann];
    return [2, ann];
  }
  if (numCols >= 4) {
    let ann = hasNine ? 4/3 : hasSix ? 2 : 4/3;
    if (yearsFound.length >= 4) return [yearsFound[2] >= yearsFound[3] ? 2 : 3, ann];
    if (!hasNine && !hasSix) {
      const ftl = fullText.toLowerCase();
      if (ftl.includes("nine months") || ftl.includes("9 months ended")) ann = 4/3;
      else if (ftl.includes("six months") || ftl.includes("6 months ended")) ann = 2;
    }
    return [2, ann];
  }
  if (numCols >= 2) {
    if (hasNine) return [0, 4/3]; if (hasSix) return [0, 2]; if (hasThree) return [0, 4];
    const ftl = fullText.toLowerCase();
    if (ftl.includes("nine months")) return [0, 4/3];
    if (ftl.includes("six months")) return [0, 2];
    return [0, 4];
  }
  if (hasNine) return [0, 4/3]; if (hasSix) return [0, 2]; if (hasThree) return [0, 4];
  return [0, 4];
}

function isLikelyIS(table, tt) {
  const isCf = (["operating activities","cash flows from"].some(x => tt.includes(x)) &&
    ["depreciation","investing activities","financing activities"].some(x => tt.includes(x)));
  if (isCf) return false;
  if (["percentage of revenue","% of revenue","period-to-period change","segment revenue"].some(x => tt.includes(x))) return false;
  for (const row of table) {
    if (!row) continue;
    let label = "";
    for (const c of row) {
      const s = String(c || "").trim();
      if (s && s !== "$" && !s.replace(/[,.\-()]/g, "").match(/^\d+$/)) { label = s.toLowerCase(); break; }
    }
    if (["total revenue","total net revenue","net sales","total net sales","revenues","net revenue"].some(x => label.includes(x))) return true;
  }
  return false;
}

// â”€â”€ Main financial extraction â”€â”€
function extractFinancials(allTables, scale, is10q, fullText) {
  const r = {};
  let bestIS = null, bestISAnn = 999;
  for (const table of allTables) {
    if (!table || table.length < 3) continue;
    const tt = table.flat().map(c => String(c || "")).join(" ").toLowerCase();
    const hasNI = tt.includes("net income") || tt.includes("net earnings") || tt.includes("net loss");
    if (isLikelyIS(table, tt) && hasNI && is10q) {
      const [, ann] = detectPeriod(table, fullText, is10q);
      if (ann < bestISAnn) { bestIS = table; bestISAnn = ann; }
    }
  }

  for (const table of allTables) {
    if (!table || table.length < 3) continue;
    const tt = table.flat().map(c => String(c || "")).join(" ").toLowerCase();
    let tableScale = detectScale(tt);
    let effScale = tableScale !== 1000 ? tableScale : scale;
    if (tableScale === 1000 && effScale >= 1000) {
      let bigCount = 0;
      for (const row of table.slice(1, 10))
        for (const c of row)
          if ((String(c||"").replace(/[^0-9]/g,"")).length >= 8) bigCount++;
      if (bigCount >= 3) effScale = 1;
    }
    const hasRev = isLikelyIS(table, tt);
    const hasNI = tt.includes("net income") || tt.includes("net earnings") || tt.includes("net loss");

    if (hasRev && hasNI) {
      if (is10q && bestIS !== null && table !== bestIS) continue;
      const [col, ann] = detectPeriod(table, fullText, is10q);
      for (const [fld, lbl] of [["revenue",LABELS.rev],["operating_income",LABELS.oi],["net_income",LABELS.ni],["gross_profit",LABELS.gp]]) {
        if (!(fld in r)) {
          let v = findValue(table, lbl, col);
          if (v === null && col > 0) { v = findValue(table, lbl, 0); if (v !== null) { r[fld] = v * effScale * (is10q ? 4 : 1); continue; } }
          if (v !== null) r[fld] = v * effScale * ann;
        }
      }
      if (!("revenue_prior" in r) && "revenue" in r) {
        const vp = findValue(table, LABELS.rev, !is10q && col > 0 ? col - 1 : col + 1);
        if (vp !== null && vp > 0) {
          const cur = ann ? r.revenue / effScale / ann : r.revenue;
          if (vp / cur > 0.1 && vp / cur < 10) r.revenue_prior = vp * effScale * ann;
        }
      }
      if (!("eps_diluted" in r)) {
        let v = findValue(table, ["diluted earnings per","diluted net income per","earnings per common share","diluted loss per","basic and diluted loss per","net loss per"], col);
        if (v === null) {
          for (const row of table) {
            if (!row) continue;
            const rt = row.map(c => String(c||"")).join(" ").toLowerCase();
            if (!rt.includes("diluted") || rt.includes("shares") || rt.includes("weighted")) continue;
            const raw = row.map(c => String(c||"")).join(" ");
            if (!raw.includes("$")) continue;
            const merged = []; let mi = 0;
            while (mi < row.length) {
              const s = String(row[mi]||"").trim();
              if (s==="$" && mi+1<row.length) { merged.push("$"+String(row[mi+1]||"").trim()); mi+=2; }
              else { merged.push(s); mi++; }
            }
            const nums = merged.map(c => cleanNum(c)).filter(n => n !== null);
            if (nums.length > col && Math.abs(nums[col]) < 500) { v = nums[col]; break; }
            else if (nums.length && Math.abs(nums[0]) < 500) { v = nums[0]; break; }
          }
        }
        if (v !== null && Math.abs(v) < 500) r.eps_diluted = is10q ? v * ann : v;
      }
      if (!("shares_diluted" in r)) {
        let v = findValue(table, LABELS.shares_dil, col);
        if (v === null && col > 0) v = findValue(table, LABELS.shares_dil, 0);
        if (v !== null && v > 0) r.shares_diluted = v * effScale;
      }
    }

    // Balance sheet
    const isBSCombined = tt.includes("total assets") && ["stockholders","equity","shareholders","shareowners"].some(x => tt.includes(x));
    const isBSAssets = tt.includes("total assets") && (tt.includes("cash and cash") || tt.includes("current assets"));
    const isBSLiabEq = !tt.includes("total assets") && ["total equity","total stockholders","total shareholders"].some(x => tt.includes(x)) && ["total liabilities","long-term debt"].some(x => tt.includes(x));
    if (isBSCombined || isBSAssets || isBSLiabEq) {
      const [bsCol] = detectPeriod(table, fullText, is10q);
      for (const [fld, lbl] of [["total_assets",LABELS.ta],["cash",LABELS.cash],["long_term_debt",LABELS.debt],["total_liabilities",LABELS.tl],["stockholders_equity",LABELS.eq]]) {
        if (!(fld in r)) {
          const excl = fld === "long_term_debt" ? ["due within","current portion","current maturities"] : null;
          let v = findValue(table, lbl, bsCol, excl);
          if (v === null && bsCol > 0) v = findValue(table, lbl, 0, excl);
          if (v !== null) r[fld] = v * effScale;
        }
      }
    }

    // Cash flow
    const isCF = ["operating activities","cash flows from","cash provided by"].some(x => tt.includes(x)) &&
      ["depreciation","investing","capital","financing activities","property and equipment","net cash"].some(x => tt.includes(x));
    if (isCF) {
      const [cfCol, cfAnn] = detectPeriod(table, fullText, is10q);
      for (const [fld, lbl] of [["operating_cf",LABELS.ocf],["capex",LABELS.capex],["depreciation",LABELS.da]]) {
        if (!(fld in r)) {
          let v = findValue(table, lbl, cfCol);
          if (v === null && cfCol > 0) v = findValue(table, lbl, 0);
          if (v !== null) r[fld] = (fld === "capex" ? Math.abs(v) : v) * effScale * cfAnn;
        }
      }
    }
  }

  if ("operating_cf" in r && "capex" in r) r.fcf = r.operating_cf - r.capex;
  else if ("operating_cf" in r) { r.capex = 0; r.fcf = r.operating_cf; }

  // Fallback shares from NI/EPS
  if (!("shares_diluted" in r) && r.net_income && r.eps_diluted && Math.abs(r.eps_diluted) > 0.01)
    r.shares_diluted = Math.abs(r.net_income / r.eps_diluted);

  // Fallback shares from cover page
  if (!("shares_diluted" in r)) {
    const ftl = fullText.toLowerCase();
    const matches = [...ftl.matchAll(/(?:shares?\s+)?outstanding/g)];
    for (const m of matches) {
      const start = Math.max(0, m.index - 250);
      const end = Math.min(ftl.length, m.index + m[0].length + 250);
      const window = ftl.slice(start, end);
      if (["loan","debt","principal","option","warrant","rsu","preferred","authorized"].some(x => window.includes(x))) continue;
      if (!["common","share","class a","class b","class c","registrant"].some(x => window.includes(x))) continue;
      const nums = [...window.matchAll(/[\d,]{7,}/g)];
      for (const n of nums) {
        const val = parseFloat(n[0].replace(/,/g, ""));
        if (val > 1e6 && val < 1e11) { r.shares_diluted = val; break; }
      }
      if ("shares_diluted" in r) break;
    }
  }
  return r;
}

// â”€â”€ HTML Parser (uses browser DOMParser) â”€â”€
function parseHTMLFiling(content, filename) {
  const parser = new DOMParser();
  const doc = parser.parseFromString(content, "text/html");
  const fullText = doc.body ? doc.body.innerText || doc.body.textContent || "" : "";
  const scale = detectScale(fullText);
  const [form, is10q] = detectForm(fullText, filename);
  const allTables = [];
  for (const te of doc.querySelectorAll("table")) {
    const rows = [];
    for (const tr of te.querySelectorAll("tr")) {
      const cells = [...tr.querySelectorAll("td, th")].map(td => (td.innerText || td.textContent || "").trim());
      if (cells.some(c => c)) rows.push(cells);
    }
    if (rows.length) allTables.push(rows);
  }
  const r = extractFinancials(allTables, scale, is10q, fullText);
  r._form = form; r._scale = scale; r._tables = allTables.length;
  const [sector, confidence] = detectSector(fullText);
  r._sector = sector; r._sector_confidence = confidence;
  return [r, fullText];
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DCF ENGINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var BETAS = { hyperscaler:1.15, bank:0.90, ep:1.20, midstream:0.85, saas_tech:1.15, pharma:0.80, fintech:1.10, consumer:1.05, industrial:1.00, utility:0.55, telecom:0.80, insurance:0.75, general:1.00 };

function calcWacc(sector, beta, debtRatio = 0) {
  const rf = 0.045, erp = 0.055;
  const b = beta || BETAS[sector] || 1.0;
  const coe = rf + b * erp;
  if (sector === "bank" || sector === "insurance") return coe;
  return coe * (1 - debtRatio) + 0.055 * 0.79 * debtRatio;
}

function dcfFcf(fcf, growth, tm, wacc, shares, nc = 0) {
  if (fcf <= 0 || shares <= 0) return 0;
  let cf = fcf, pv = 0;
  for (let i = 0; i < growth.length; i++) { cf *= (1 + growth[i]); pv += cf / Math.pow(1 + wacc, i + 1); }
  pv += cf * tm / Math.pow(1 + wacc, growth.length);
  return Math.max((pv + nc) / shares, 0);
}

function dcfEv(fcff, growth, tm, wacc, shares, nd = 0) {
  if (fcff <= 0 || shares <= 0) return 0;
  let cf = fcff, pv = 0;
  for (let i = 0; i < growth.length; i++) { cf *= (1 + growth[i]); pv += cf / Math.pow(1 + wacc, i + 1); }
  pv += cf * tm / Math.pow(1 + wacc, growth.length);
  return Math.max((pv - nd) / shares, 0);
}

function ddmBank(equity, trailingRoe, nearRoe, terminalRoe, coe, shares, payout = 0.40) {
  if (equity <= 0 || shares <= 0) return 0;
  const retention = 1 - payout;
  let b = equity, pv = 0;
  for (let yr = 1; yr <= 10; yr++) {
    let roe;
    if (yr <= 3) roe = nearRoe;
    else if (yr <= 7) roe = nearRoe + (terminalRoe - nearRoe) * ((yr - 3) / 4);
    else roe = terminalRoe;
    roe = Math.max(roe, 0.005);
    const earnings = b * roe;
    pv += earnings * payout / Math.pow(1 + coe, yr);
    b += earnings * retention;
  }
  let g = Math.min(retention * terminalRoe, 0.045);
  if (g >= coe) g = coe - 0.005;
  const justified = (coe > g && terminalRoe > g) ? (terminalRoe - g) / (coe - g) : 1.0;
  const termPtbv = Math.min(Math.max(justified, 0.4), 2.5);
  pv += b * termPtbv / Math.pow(1 + coe, 10);
  return Math.max(pv / shares, 0);
}

function makeBankScenarios(trailingRoe) {
  const bt = Math.max(Math.min(trailingRoe * 0.88, 0.14), 0.08);
  return [
    ["ğŸ”¥ Rate Tailwind", 0.10, Math.min(trailingRoe + 0.02, 0.20), Math.min(bt + 0.02, 0.16)],
    ["ğŸ“ˆ Strong Cycle", 0.25, Math.min(trailingRoe + 0.005, 0.18), Math.min(bt + 0.01, 0.15)],
    ["ğŸ“Š Base", 0.35, trailingRoe, bt],
    ["ğŸ“‰ NIM Compress", 0.20, Math.max(trailingRoe - 0.025, 0.06), Math.max(bt - 0.02, 0.08)],
    ["ğŸ’€ Credit Crisis", 0.10, Math.max(trailingRoe - 0.07, 0.03), Math.max(bt - 0.05, 0.05)],
  ];
}

// â”€â”€ Scenarios with margin factors â”€â”€
var SCENARIOS = {
  hyperscaler: [
    ["ğŸ”¥ Dominance",.10,[.25,.22,.19,.16,.14,.12,.10,.09,.08,.07],30,1.10],
    ["ğŸ“ˆ Strong",.25,[.18,.16,.14,.12,.10,.09,.08,.07,.06,.05],24,1.05],
    ["ğŸ“Š Base",.35,[.13,.12,.10,.09,.08,.07,.06,.05,.05,.04],20,1.00],
    ["ğŸ“‰ Maturation",.20,[.06,.05,.05,.04,.04,.03,.03,.03,.03,.03],14,0.90],
    ["ğŸ’€ Disruption",.10,[.01,-.02,0,.02,.02,.02,.02,.02,.02,.02],9,0.75]],
  saas_tech: [
    ["ğŸ”¥ Hypergrowth",.10,[.28,.24,.20,.17,.14,.11,.09,.08,.07,.06],25,1.15],
    ["ğŸ“ˆ Strong",.25,[.18,.16,.14,.12,.10,.08,.07,.06,.05,.05],20,1.05],
    ["ğŸ“Š Base",.35,[.11,.10,.09,.08,.07,.06,.05,.05,.04,.04],15,1.00],
    ["ğŸ“‰ Decel",.20,[.03,.03,.03,.02,.02,.02,.02,.02,.02,.02],10,0.85],
    ["ğŸ’€ Disrupt",.10,[-.03,-.05,-.02,.01,.02,.02,.01,.01,.01,.01],6,0.60]],
  pharma: [
    ["ğŸ”¥ Pipeline",.10,[.16,.14,.12,.10,.08,.07,.06,.05,.04,.04],16,1.10],
    ["ğŸ“ˆ Growth",.25,[.09,.08,.07,.06,.06,.05,.05,.04,.04,.03],13,1.00],
    ["ğŸ“Š Base",.35,[.04,.04,.04,.03,.03,.03,.02,.02,.02,.02],10,1.00],
    ["ğŸ“‰ Patent",.20,[-.01,-.05,-.08,-.03,.01,.02,.02,.01,.01,.01],7,0.80],
    ["ğŸ’€ Fail",.10,[-.08,-.15,-.10,-.04,.01,.01,.01,.01,.01,.01],4,0.50]],
  ep: [
    ["ğŸ”¥ $85 Oil",.10,[.22,.18,.14,.10,.07,.05,.04,.03,.03,.02],5.0,1.10],
    ["ğŸ“ˆ $75 Oil",.25,[.10,.08,.06,.05,.04,.03,.03,.02,.02,.02],4.5,1.00],
    ["ğŸ“Š $65 Oil",.35,[.03,.02,.02,.02,.01,.01,.01,.01,.01,.01],4.0,1.00],
    ["ğŸ“‰ $50 Oil",.20,[-.08,-.12,-.05,.01,.02,.01,.01,.01,.01,.01],3.0,0.70],
    ["ğŸ’€ $40 Crash",.10,[-.18,-.22,-.08,-.02,.01,.01,.01,.01,.01,.01],2.5,0.45]],
  midstream: [
    ["ğŸ”¥ Boom",.10,[.10,.09,.07,.06,.05,.05,.04,.03,.03,.03],9,1.05],
    ["ğŸ“ˆ Steady",.25,[.06,.05,.05,.04,.04,.03,.03,.03,.02,.02],8,1.00],
    ["ğŸ“Š Base",.35,[.03,.03,.02,.02,.02,.02,.02,.02,.02,.02],7,1.00],
    ["ğŸ“‰ Decline",.20,[-.01,-.02,-.01,.01,.01,.01,.01,.01,.01,.01],5,0.85],
    ["ğŸ’€ Transition",.10,[-.05,-.07,-.04,-.02,0,0,0,0,0,0],3,0.65]],
  utility: [
    ["ğŸ”¥ Rate Growth",.10,[.08,.07,.06,.06,.05,.05,.04,.04,.04,.03],16,1.05],
    ["ğŸ“ˆ Constructive",.25,[.05,.05,.05,.04,.04,.04,.03,.03,.03,.03],14,1.00],
    ["ğŸ“Š Base",.35,[.03,.03,.03,.03,.03,.02,.02,.02,.02,.02],12,1.00],
    ["ğŸ“‰ Headwinds",.20,[.01,.01,.02,.02,.02,.02,.02,.02,.02,.02],10,0.90],
    ["ğŸ’€ Adverse",.10,[-.01,-.02,0,.01,.01,.01,.01,.01,.01,.01],7,0.75]],
  fintech: [
    ["ğŸ”¥ Network Expansion",.10,[.18,.16,.14,.12,.10,.09,.08,.07,.06,.06],22,1.10],
    ["ğŸ“ˆ Steady Growth",.25,[.12,.11,.10,.09,.08,.07,.07,.06,.06,.05],18,1.00],
    ["ğŸ“Š Base",.35,[.08,.07,.07,.06,.06,.05,.05,.05,.04,.04],15,1.00],
    ["ğŸ“‰ Compression",.20,[.03,.03,.03,.03,.03,.03,.03,.02,.02,.02],10,0.80],
    ["ğŸ’€ Disruption",.10,[-.02,-.04,-.02,.01,.02,.02,.02,.02,.01,.01],6,0.55]],
  consumer: [
    ["ğŸ”¥ Share Gains",.10,[.12,.10,.08,.07,.06,.05,.05,.04,.04,.03],14,1.10],
    ["ğŸ“ˆ Steady",.25,[.07,.06,.06,.05,.05,.04,.04,.04,.03,.03],12,1.00],
    ["ğŸ“Š Base",.35,[.04,.04,.03,.03,.03,.03,.03,.02,.02,.02],10,1.00],
    ["ğŸ“‰ Recession",.20,[-.02,-.04,-.01,.02,.03,.03,.02,.02,.02,.02],7,0.75],
    ["ğŸ’€ Secular Decline",.10,[-.05,-.08,-.06,-.03,-.01,0,0,0,0,0],4,0.50]],
  industrial: [
    ["ğŸ”¥ Cycle Peak",.10,[.20,.15,.10,.08,.06,.05,.04,.04,.03,.03],16,1.10],
    ["ğŸ“ˆ Expansion",.25,[.12,.10,.08,.06,.05,.05,.04,.04,.03,.03],13,1.00],
    ["ğŸ“Š Base",.35,[.06,.05,.05,.04,.04,.03,.03,.03,.03,.02],11,1.00],
    ["ğŸ“‰ Downcycle",.20,[-.05,-.10,-.03,.04,.05,.04,.03,.03,.03,.02],8,0.75],
    ["ğŸ’€ Deep Recession",.10,[-.12,-.18,-.08,.02,.04,.04,.03,.02,.02,.02],5,0.50]],
  telecom: [
    ["ğŸ”¥ 5G/Fiber Cycle",.10,[.08,.07,.06,.05,.04,.04,.03,.03,.03,.03],12,1.05],
    ["ğŸ“ˆ Steady",.25,[.04,.04,.04,.03,.03,.03,.03,.02,.02,.02],10,1.00],
    ["ğŸ“Š Base",.35,[.02,.02,.02,.02,.02,.02,.02,.02,.02,.02],8,1.00],
    ["ğŸ“‰ Cord-Cutting",.20,[-.01,-.02,-.01,.01,.01,.01,.01,.01,.01,.01],6,0.85],
    ["ğŸ’€ Legacy Decline",.10,[-.04,-.06,-.04,-.02,-.01,0,0,0,0,0],4,0.65]],
  insurance: [
    ["ğŸ”¥ MLR Improve",.10,[.15,.13,.11,.09,.08,.07,.06,.05,.05,.04],16,1.10],
    ["ğŸ“ˆ Growth",.25,[.09,.08,.07,.06,.06,.05,.05,.04,.04,.04],13,1.00],
    ["ğŸ“Š Base",.35,[.05,.05,.04,.04,.04,.03,.03,.03,.03,.03],11,1.00],
    ["ğŸ“‰ MLR Pressure",.20,[.01,0,.01,.02,.02,.02,.02,.02,.02,.02],8,0.80],
    ["ğŸ’€ Regulatory",.10,[-.03,-.05,-.03,0,.01,.01,.01,.01,.01,.01],5,0.60]],
  general: [
    ["ğŸ”¥ Bull Extreme",.10,[.18,.15,.13,.11,.09,.08,.07,.06,.05,.05],18,1.10],
    ["ğŸ“ˆ Bull Base",.25,[.10,.09,.08,.07,.06,.06,.05,.04,.04,.04],14,1.00],
    ["ğŸ“Š Base",.35,[.05,.05,.05,.04,.04,.03,.03,.03,.03,.03],12,1.00],
    ["ğŸ“‰ Bear Base",.20,[.01,.01,.02,.02,.02,.02,.02,.02,.02,.02],8,0.80],
    ["ğŸ’€ Bear Extreme",.10,[-.04,-.06,-.03,.01,.01,.01,.01,.01,.01,.01],5,0.55]],
};

var CAPEX_FACTORS = { hyperscaler:0.65, saas_tech:0.75, pharma:0.80, fintech:0.80, consumer:0.85, industrial:0.95, telecom:0.90, utility:1.10, ep:0.90, midstream:0.90, bank:1.00, insurance:0.95, general:0.85 };

function computeCapex(fins, sector, model = "da_proxy") {
  const ocf = fins.operating_cf || 0, capex = fins.capex || 0, da = fins.depreciation || 0;
  if (ocf <= 0 || capex <= 0) return null;
  if (model === "reported") return { fcf_reported: ocf - capex, fcf_used: ocf - capex, method: "Reported" };
  const factor = CAPEX_FACTORS[sector] || 0.85;
  let maint = da > 0 ? da * factor : capex * Math.min(factor, 0.80);
  maint = Math.min(maint, capex);
  const fcfUsed = ocf - maint;
  return { fcf_reported: ocf - capex, fcf_used: Math.max(fcfUsed, 0), method: `D&AÃ—${factor} proxy` };
}

function solveImplied(fcf, price, shares, nc, wacc, tm) {
  if (fcf <= 0 || price <= 0 || shares <= 0) return null;
  const target = price * shares - nc;
  const pv = (g) => { let cf = fcf, s = 0; for (let t = 1; t <= 10; t++) { cf *= (1+g); s += cf/Math.pow(1+wacc,t); } return s + cf*tm/Math.pow(1+wacc,10) - target; };
  let lo = -0.20, hi = 0.80;
  if (pv(lo) * pv(hi) >= 0) return pv(hi) < 0 ? null : lo;
  for (let i = 0; i < 50; i++) { const m = (lo+hi)/2; if (pv(m) > 0) hi = m; else lo = m; }
  return (lo+hi)/2;
}

function solveImpliedRev(rev, fcf, price, shares, nc, wacc, tm, sector) {
  if (rev <= 0 || fcf <= 0 || price <= 0 || shares <= 0) return null;
  const target = price * shares - nc;
  const cm = fcf / rev;
  const mm = Math.max(cm, {hyperscaler:.20,saas_tech:.25,pharma:.22,fintech:.20,consumer:.10,industrial:.12,ep:.08,midstream:.15,bank:.15,utility:.12,telecom:.12,insurance:.10,general:.12}[sector] || .12);
  const pv = (g) => { let r = rev, s = 0; for (let t=1;t<=10;t++) { r*=(1+g); const margin=cm+(mm-cm)*(t/10); s+=r*margin/Math.pow(1+wacc,t); } return s+r*mm*tm/Math.pow(1+wacc,10)-target; };
  let lo = -0.20, hi = 0.80;
  if (pv(lo)*pv(hi) >= 0) return pv(hi) < 0 ? null : lo;
  for (let i=0;i<50;i++) { const m=(lo+hi)/2; if(pv(m)>0) hi=m; else lo=m; }
  return (lo+hi)/2;
}

// â”€â”€ Main DCF engine â”€â”€
function runDcf(fins, price, sharesMil, sector, beta = null) {
  const shares = sharesMil * 1e6, mcap = price * shares;
  let fcf = fins.fcf || 0, ni = fins.net_income || 0, rev = fins.revenue || 0;
  const oi = fins.operating_income || 0, da = fins.depreciation || 0;
  const ocf = fins.operating_cf || 0, capex = fins.capex || 0;
  const cash = fins.cash || 0, debt = fins.long_term_debt || 0, equity = fins.stockholders_equity || 0;

  const capexDer = computeCapex(fins, sector);
  if (capexDer && capexDer.fcf_used > 0) fcf = capexDer.fcf_used;

  // OCF distortion
  if (ni > 0 && ocf > 0 && ocf < ni * 0.30 && fcf < ni * 0.15) {
    const niFcf = ni * (["hyperscaler","saas_tech","pharma","fintech"].includes(sector) ? 0.85 : 0.70);
    if (niFcf > fcf) { fcf = niFcf; if (capexDer) capexDer.method += " â†’ NI fallback"; }
  }

  let ebitda = (oi && da) ? oi + da : oi ? oi * 1.25 : ocf ? ocf * 1.1 : ni ? ni / 0.65 : 0;
  const nd = debt - cash; let nc = cash - debt;

  if (fcf <= 0) {
    if (ni > 0) fcf = ni * (["hyperscaler","saas_tech","pharma","fintech"].includes(sector) ? 0.85 : 0.70);
    else if (rev > 0) fcf = rev * ({hyperscaler:.15,saas_tech:.12,pharma:.10,ep:.08,utility:.10,insurance:.06}[sector] || .07);
    else return { error: "Cannot derive FCF" };
  }
  if (fcf <= 0) return { error: "Negative FCF" };

  // SBC haircut
  let sbcHaircut = 0;
  if (["saas_tech","hyperscaler","fintech"].includes(sector) && ni > 0 && ocf > 0) {
    const sbcEst = Math.max(ocf - ni - da * 0.3, 0);
    if (sbcEst > ni * 0.10) sbcHaircut = sbcEst * 0.50;
  }
  if (sbcHaircut > 0 && sbcHaircut < fcf * 0.60) {
    fcf -= sbcHaircut;
    if (capexDer) capexDer.method += ` â†’ SBC $${Math.round(sbcHaircut/1e6)}M`;
  }

  // Buyback machine
  const isBBM = equity < 0 && ni > 0 && fcf > 0 && ocf > debt * 0.08;
  if (isBBM) { const maxPenalty = fcf * 3; nc = -Math.min(nd, maxPenalty); }

  const ev = mcap + nd;
  const dr = ev > 0 ? Math.min(debt / Math.max(ev, 1), 0.6) : 0;
  const wacc = calcWacc(sector, beta, dr);

  // Bank DDM
  if (sector === "bank") {
    let trailingRoe = equity > 0 ? ni / equity : 0.10;
    trailingRoe = Math.max(Math.min(trailingRoe, 0.30), 0.01);
    const bankScens = makeBankScenarios(trailingRoe);
    const tg = rev > 0 && (fins.revenue_prior||0) > 0 ? (rev - fins.revenue_prior) / fins.revenue_prior : null;
    const scenResults = []; let pwFv = 0;
    for (const [name, prob, nearRoe, termRoe] of bankScens) {
      const fv = ddmBank(equity > 0 ? equity : mcap * 0.6, trailingRoe, nearRoe, termRoe, wacc, shares);
      pwFv += prob * fv;
      scenResults.push({ name, prob, fv: Math.round(fv*100)/100, upside: Math.round((fv-price)/price*10000)/100 });
    }
    const pwUp = Math.round((pwFv-price)/price*10000)/100;
    return { pw_fv: Math.round(pwFv*100)/100, pw_up: pwUp, verdict: pwUp > 30 ? "STRONG BUY" : pwUp > 10 ? "BUY" : pwUp > -10 ? "HOLD" : pwUp > -25 ? "SELL" : "STRONG SELL", wacc, scenarios: scenResults, trailing_growth: tg, implied_fcf_growth: null, implied_rev_growth: null, inputs: { revenue:rev, net_income:ni, fcf, ebitda, operating_cf:ocf, capex, depreciation:da, cash, debt, equity, shares, capex_method: "DDM" }, sanity_flags: [], is_buyback_machine: false, sbc_haircut: 0 };
  }

  // Standard DCF
  const templates = SCENARIOS[sector] || SCENARIOS.general;
  let trailingGrowth = null;
  if (rev > 0 && (fins.revenue_prior||0) > 0) trailingGrowth = (rev - fins.revenue_prior) / fins.revenue_prior;
  const sectorBaseY1 = templates[2][2][0];

  // Dynamic probs
  let probs = templates.map(t => t[1]);
  if (rev > 0) {
    const isLarge = rev > 10e9, isMature = trailingGrowth !== null && Math.abs(trailingGrowth) < 0.08;
    const isHyper = trailingGrowth !== null && trailingGrowth > 0.40;
    const isProfitable = ni / rev > 0.10;
    if (isLarge && isMature && isProfitable) probs = [0.05, 0.20, 0.45, 0.20, 0.10];
    else if (isHyper && !isLarge && !isProfitable) probs = [0.08, 0.18, 0.30, 0.22, 0.22];
    else if (isHyper && !isLarge && isProfitable) probs = [0.12, 0.22, 0.30, 0.20, 0.16];
    else if (!isProfitable) probs = [0.05, 0.20, 0.30, 0.25, 0.20];
  }

  const scenResults = []; let pwFv = 0;
  for (let idx = 0; idx < templates.length; idx++) {
    const [name, , pathTemplate, terminal, marginFactor] = templates[idx];
    const prob = probs[idx];
    let path = [...pathTemplate];

    if (trailingGrowth !== null) {
      let premium = trailingGrowth - sectorBaseY1;
      const maxPrem = Math.min(Math.max(trailingGrowth * 0.60, 0), 0.50);
      premium = Math.max(-0.20, Math.min(premium, maxPrem));
      const fadeSpeed = Math.abs(premium) < 0.15 ? 5 : 3;
      if (Math.abs(premium) > 0.02) path = path.map((g, i) => g + premium * Math.max(0, 1 - i / fadeSpeed));
    }

    const effFcf = fcf * marginFactor;
    let fv;
    if (["ep","midstream"].includes(sector) && nd > 0) {
      const fcff = ebitda > 0 ? ebitda * 0.55 * marginFactor : effFcf * 1.3;
      fv = dcfEv(fcff, path, terminal, wacc, shares, Math.max(nd, 0));
    } else {
      fv = dcfFcf(effFcf, path, terminal, wacc, shares, Math.max(nc, 0));
    }
    pwFv += prob * fv;
    scenResults.push({ name, prob, fv: Math.round(fv*100)/100, upside: Math.round((fv-price)/price*10000)/100 });
  }

  const pwUp = Math.round((pwFv-price)/price*10000)/100;
  const sanityFlags = [];
  if (rev > 0 && pwFv > 0) {
    const ips = (pwFv * shares) / rev;
    if (ips < 1.0 && ni > 0 && ni/rev > 0.15) sanityFlags.push(`FV implies ${ips.toFixed(1)}x rev on ${Math.round(ni/rev*100)}% margin`);
    if (ips > 50) sanityFlags.push(`FV implies ${Math.round(ips)}x rev (extreme)`);
    if (scenResults.every(s => s.upside > 20)) sanityFlags.push("All scenarios bullish");
    if (scenResults.every(s => s.upside < -20)) sanityFlags.push("All scenarios bearish â€” model may miss value drivers");
  }

  const baseTm = templates[2][3];
  const impliedFcf = solveImplied(fcf, price, shares, nc, wacc, baseTm);
  const impliedRev = solveImpliedRev(rev, fcf, price, shares, nc, wacc, baseTm, sector);

  return {
    pw_fv: Math.round(pwFv*100)/100, pw_up: pwUp,
    verdict: pwUp > 30 ? "STRONG BUY" : pwUp > 10 ? "BUY" : pwUp > -10 ? "HOLD" : pwUp > -25 ? "SELL" : "STRONG SELL",
    wacc, scenarios: scenResults, trailing_growth: trailingGrowth,
    implied_fcf_growth: impliedFcf, implied_rev_growth: impliedRev,
    sanity_flags: sanityFlags, is_buyback_machine: isBBM, sbc_haircut: sbcHaircut,
    inputs: { revenue:rev, net_income:ni, fcf, ebitda, operating_cf:ocf, capex, depreciation:da, cash, debt, equity, shares, fcf_reported: capexDer?.fcf_reported, capex_method: capexDer?.method || "â€”" },
  };
}

// â”€â”€ Format helpers â”€â”€
function fmt(x) {
  if (x == null) return "â€”";
  const a = Math.abs(x);
  const s = x < 0 ? "-" : "";
  if (a >= 1e12) return `${s}$${(a/1e12).toFixed(1)}T`;
  if (a >= 1e9) return `${s}$${(a/1e9).toFixed(1)}B`;
  if (a >= 1e6) return `${s}$${Math.round(a/1e6)}M`;
  if (a >= 1e3) return `${s}$${Math.round(a/1e3)}K`;
  return `${s}$${Math.round(a)}`;
}
function pct(x) { return x != null ? `${(x*100).toFixed(1)}%` : "â€”"; }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// REACT UI
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var verdictColor = function(v) {
  if (v?.includes("STRONG BUY")) return "#00e676";
  if (v?.includes("BUY")) return "#66bb6a";
  if (v?.includes("HOLD")) return "#fdd835";
  if (v?.includes("SELL") && v?.includes("STRONG")) return "#ff1744";
  if (v?.includes("SELL")) return "#ef5350";
  return "#999";
};



// â•â•â• STATE â•â•â•
var currentFins = null, currentResult = null;
var recents = JSON.parse(localStorage.getItem("cl_rec") || "[]");

// Init sector dropdown
try {
  (function(){
    var s = document.getElementById("sector");
    var h = '<option value="auto">Auto-detect</option>';
    for (var k in SECTOR_NAMES) h += '<option value="' + k + '">' + SECTOR_NAMES[k] + '</option>';
    s.innerHTML = h;
  })();
  renderRecents();
  document.getElementById("ticker").addEventListener("keydown", function(e) {
    if (e.key === "Enter") pullFiling();
  });

  // Check if running from local file
  if (window.location.protocol === "file:") {
    log("\u26A0 Running from local file - EDGAR pull requires hosting.", "warn");
    log("Upload file manually, or host on GitHub Pages.", "warn");
  }
  } catch(initErr) { console.error("Init error:", initErr); }

// â•â•â• SEC EDGAR FETCH â•â•â•
var PROXY = "https://corsproxy.io/?";
var PROXY2 = "https://api.allorigins.win/raw?url=";

async function secGet(url) {
  var custom = document.getElementById("proxyUrl").value.trim();
  if (custom) {
    try {
      var controller = new AbortController();
      var timeout = setTimeout(function() { controller.abort(); }, 15000);
      var r = await fetch(custom + "?url=" + encodeURIComponent(url), {signal: controller.signal});
      clearTimeout(timeout);
      if (r.ok) return r;
      log("  Custom proxy returned " + r.status, "warn");
    } catch(e) {
      log("  Custom proxy failed: " + (e.name === "AbortError" ? "timeout" : e.message), "warn");
    }
  }
  // Try corsproxy first (fast), then allorigins (larger files)
  try {
    var r = await fetch(PROXY + encodeURIComponent(url));
    if (r.ok) return r;
  } catch(e) {}
  try {
    var r2 = await fetch(PROXY2 + encodeURIComponent(url));
    if (r2.ok) return r2;
  } catch(e) {}
  throw new Error("Proxy failed for: " + url.substring(0, 60));
}

async function proxyFetch(url) {
  var custom = document.getElementById("proxyUrl").value.trim();
  if (custom) {
    try {
      var controller = new AbortController();
      var timeout = setTimeout(function() { controller.abort(); }, 10000);
      var r = await fetch(custom + "?url=" + encodeURIComponent(url), {signal: controller.signal});
      clearTimeout(timeout);
      if (r.ok) return r;
    } catch(e) {}
  }
  var proxies = [
    "https://corsproxy.io/?",
    "https://api.allorigins.win/raw?url=",
    "https://api.codetabs.com/v1/proxy?quest="
  ];
  for (var pi = 0; pi < proxies.length; pi++) {
    try {
      var controller = new AbortController();
      var timeout = setTimeout(function() { controller.abort(); }, 8000);
      var r = await fetch(proxies[pi] + encodeURIComponent(url), {signal: controller.signal});
      clearTimeout(timeout);
      if (r.ok) return r;
    } catch(e) {}
  }
  throw new Error("Fetch failed");
}

async function pullFiling() {
  var ticker = document.getElementById("ticker").value.trim().toUpperCase();
  if (!ticker) { log("Enter a ticker", "err"); return; }
  document.getElementById("ticker").value = ticker;
  var btn = document.getElementById("pullBtn");
  btn.disabled = true; btn.textContent = "PULLING...";
  log("Starting pull for " + ticker + "...", "info");
  try {
    // Step 1: Look up CIK
    log("Looking up " + ticker + "...", "info");
    var r1 = await secGet("https://www.sec.gov/files/company_tickers.json");
    var tickers = await r1.json();
    var cik = null, name = ticker;
    var vals = Object.values(tickers);
    for (var i = 0; i < vals.length; i++) {
      if (vals[i].ticker.toUpperCase() === ticker) {
        cik = String(vals[i].cik_str).padStart(10, "0");
        name = vals[i].title; break;
      }
    }
    if (!cik) throw new Error("Ticker not found in SEC");
    log("CIK " + cik + " \u2014 " + name, "ok");

    // Step 2: Get filing metadata to determine form type and date
    var formType = document.getElementById("formType").value;
    log("Searching for " + formType + "...", "info");
    var r2 = await secGet("https://data.sec.gov/submissions/CIK" + cik + ".json");
    var subData = await r2.json();
    var rec = (subData.filings || {}).recent || {};
    var forms = rec.form || [], dates = rec.filingDate || [];
    var filingInfo = null;
    var targets = [formType, formType + "/A"];
    for (var ti = 0; ti < targets.length && !filingInfo; ti++)
      for (var i = 0; i < forms.length; i++)
        if (forms[i] === targets[ti]) { filingInfo = {form: forms[i], date: dates[i]}; break; }
    if (!filingInfo) {
      var alt = formType === "10-Q" ? "10-K" : "10-Q";
      targets = [alt, alt + "/A"];
      for (var ti = 0; ti < targets.length && !filingInfo; ti++)
        for (var i = 0; i < forms.length; i++)
          if (forms[i] === targets[ti]) { filingInfo = {form: forms[i], date: dates[i], fb: true}; break; }
    }
    if (!filingInfo) throw new Error("No filing found");
    var is10K = filingInfo.form.indexOf("10-K") >= 0 || filingInfo.form.indexOf("20-F") >= 0;
    log("Found " + filingInfo.form + " filed " + filingInfo.date + (filingInfo.fb ? " (fallback)" : ""), "ok");

    // Step 3: Fetch individual XBRL concepts (small requests, ~10KB each)
    log("Fetching financials...", "info");
    var fins = await fetchXBRLConcepts(cik, filingInfo.date, is10K);
    fins._form = filingInfo.form;
    fins._scale = 1; // XBRL values are in raw dollars
    fins._tables = 0;

    // Detect sector from company name and SIC code
    var sic = subData.sic || "";
    var sicDesc = subData.sicDescription || "";
    var sectorResult = detectSectorFromSIC(sic, sicDesc, name);
    fins._sector = sectorResult[0];
    fins._sector_confidence = sectorResult[1];

    var fields = Object.keys(fins).filter(function(k) { return k.charAt(0) !== "_"; }).length;
    currentFins = fins;

    document.getElementById("parseStatus").className = "st ok";
    document.getElementById("parseStatus").textContent = "\u2713 " + fins._form + " | " + (SECTOR_NAMES[fins._sector] || "General") + " | " + fields + " fields (XBRL)";
    document.getElementById("inputsCard").className = "card";
    if (fins.shares_diluted && !document.getElementById("shares").value)
      document.getElementById("shares").value = (fins.shares_diluted / 1e6).toFixed(1);
    document.getElementById("sector").value = "auto";
    log("Extracted " + fields + " fields | " + (SECTOR_NAMES[fins._sector] || "General") + " | " + filingInfo.form, "ok");

    // Step 5: Fetch market data
    await fetchMarket(ticker);

    // Save recent
    recents = recents.filter(function(r) { return r !== ticker; });
    recents.unshift(ticker); recents = recents.slice(0, 8);
    localStorage.setItem("cl_rec", JSON.stringify(recents));
    renderRecents();

    // Auto-run DCF
    var p = parseFloat(document.getElementById("price").value);
    var s = parseFloat(document.getElementById("shares").value);
    if (p > 0 && s > 0) runDCFUI();

  } catch(e) { log("Error: " + e.message, "err"); }
  finally { btn.disabled = false; btn.textContent = "\u23CE PULL FROM EDGAR"; }
}


async function fetchXBRLConcepts(cik, filingDate, is10K) {
  var filingYear = parseInt(filingDate.substring(0, 4));
  var r = {};

  var concepts = [
    {field: "revenue", names: ["RevenueFromContractWithCustomerExcludingAssessedTax", "Revenues", "RevenueFromContractWithCustomerIncludingAssessedTax", "SalesRevenueNet"], type: "annual", withPrior: true},
    {field: "net_income", names: ["NetIncomeLoss", "ProfitLoss"], type: "annual"},
    {field: "operating_income", names: ["OperatingIncomeLoss"], type: "annual"},
    {field: "gross_profit", names: ["GrossProfit"], type: "annual"},
    {field: "operating_cf", names: ["NetCashProvidedByOperatingActivities", "NetCashProvidedByUsedInOperatingActivities", "NetCashProvidedByOperatingActivitiesContinuingOperations"], type: "annual"},
    {field: "capex", names: ["PaymentsToAcquirePropertyPlantAndEquipment", "PaymentsToAcquireProductiveAssets", "CapitalExpenditureDiscontinuedOperations"], type: "annual", abs: true},
    {field: "depreciation", names: ["DepreciationDepletionAndAmortization", "DepreciationAndAmortization"], type: "annual"},
    {field: "cash", names: ["CashAndCashEquivalentsAtCarryingValue", "CashCashEquivalentsAndShortTermInvestments"], type: "instant"},
    {field: "long_term_debt", names: ["LongTermDebt", "LongTermDebtNoncurrent", "LongTermDebtAndCapitalLeaseObligations"], type: "instant"},
    {field: "stockholders_equity", names: ["StockholdersEquity", "StockholdersEquityIncludingPortionAttributableToNoncontrollingInterest"], type: "instant"},
    {field: "total_assets", names: ["Assets"], type: "instant"},
    {field: "total_liabilities", names: ["Liabilities"], type: "instant"},
    {field: "eps_diluted", names: ["EarningsPerShareDiluted"], type: "perShare"},
    {field: "shares_diluted", names: ["WeightedAverageNumberOfDilutedSharesOutstanding"], type: "shares"}
  ];

  for (var ci = 0; ci < concepts.length; ci++) {
    var concept = concepts[ci];
    if (r[concept.field]) continue;
    
    for (var ni = 0; ni < concept.names.length; ni++) {
      if (r[concept.field]) break;
      try {
        var url = "https://data.sec.gov/api/xbrl/companyconcept/CIK" + cik + "/us-gaap/" + concept.names[ni] + ".json";
        var resp = await secGet(url);
        var data = await resp.json();
        var units = data.units || {};
        var values = units.USD || units.shares || units["USD/shares"] || units.pure || [];
        if (!values || !values.length) continue;

        if (concept.type === "instant") {
          // Balance sheet: most recent instant value
          var best = null, bestDate = "";
          for (var vi = 0; vi < values.length; vi++) {
            var v = values[vi];
            if (!v.end) continue;
            if (parseInt(v.end.substring(0, 4)) < filingYear - 1) continue;
            var hasStart = v.start && v.start !== "";
            if (hasStart) {
              var months = Math.round((new Date(v.end) - new Date(v.start)) / (30.44 * 86400000));
              if (months > 2) continue;
            }
            if (v.end > bestDate) { best = v.val; bestDate = v.end; }
          }
          if (best !== null) r[concept.field] = best;

        } else if (concept.type === "perShare") {
          // EPS: most recent annual (~12 month period)
          var best = null, bestDate = "";
          for (var vi = 0; vi < values.length; vi++) {
            var v = values[vi];
            if (!v.end || !v.start) continue;
            if (parseInt(v.end.substring(0, 4)) < filingYear - 1) continue;
            var months = Math.round((new Date(v.end) - new Date(v.start)) / (30.44 * 86400000));
            if (months >= 10 && months <= 14 && v.end > bestDate) {
              best = v.val; bestDate = v.end;
            }
          }
          if (best !== null) r[concept.field] = best;

        } else if (concept.type === "shares") {
          // Shares: most recent annual period, filter out unreasonable values
          var best = null, bestDate = "";
          for (var vi = 0; vi < values.length; vi++) {
            var v = values[vi];
            if (!v.end) continue;
            if (parseInt(v.end.substring(0, 4)) < filingYear - 1) continue;
            // Prefer values with a period (weighted average) over instant
            var hasStart = v.start && v.start !== "";
            if (hasStart) {
              var months = Math.round((new Date(v.end) - new Date(v.start)) / (30.44 * 86400000));
              // Prefer annual period
              if (months >= 10 && months <= 14 && v.end > bestDate) {
                best = v.val; bestDate = v.end;
              }
            }
          }
          // Fallback: most recent value of any period
          if (best === null) {
            for (var vi = 0; vi < values.length; vi++) {
              var v = values[vi];
              if (!v.end) continue;
              if (parseInt(v.end.substring(0, 4)) < filingYear - 1) continue;
              if (v.val > 0 && v.val < 1e11 && v.end > bestDate) {
                best = v.val; bestDate = v.end;
              }
            }
          }
          if (best !== null) r[concept.field] = best;

        } else {
          // Annual income/CF: get most recent ~12 month period AND prior year
          var annuals = [];
          for (var vi = 0; vi < values.length; vi++) {
            var v = values[vi];
            if (!v.end || !v.start) continue;
            if (parseInt(v.end.substring(0, 4)) < filingYear - 3) continue;
            var months = Math.round((new Date(v.end) - new Date(v.start)) / (30.44 * 86400000));
            if (months >= 10 && months <= 14) {
              annuals.push({val: v.val, end: v.end});
            }
          }
          // Sort by end date descending
          annuals.sort(function(a, b) { return b.end.localeCompare(a.end); });
          // Deduplicate by end date (keep first = most recent filing)
          var seen = {};
          var unique = [];
          for (var ai = 0; ai < annuals.length; ai++) {
            if (!seen[annuals[ai].end]) {
              seen[annuals[ai].end] = true;
              unique.push(annuals[ai]);
            }
          }
          if (unique.length > 0) {
            r[concept.field] = concept.abs ? Math.abs(unique[0].val) : unique[0].val;
            // Save prior year for trailing growth
            if (concept.withPrior && unique.length >= 2) {
              r[concept.field + "_prior"] = unique[1].val;
            }
          }
        }
      } catch(e) { continue; }
    }
    if (r[concept.field]) { log("  \u2713 " + concept.field + " = " + (Math.abs(r[concept.field]) > 1e6 ? "$" + (r[concept.field]/1e9).toFixed(1) + "B" : r[concept.field]), "ok"); } else if (ci === concepts.length - 1 || ci % 3 === 0) { log("  " + (ci + 1) + "/" + concepts.length + " concepts...", "info"); }
  }

  // Derived
  if (r.operating_cf && r.capex) r.fcf = r.operating_cf - r.capex;
  else if (r.operating_cf) { r.capex = 0; r.fcf = r.operating_cf; }

  // If shares still missing, try to derive from NI / EPS
  if (!r.shares_diluted && r.net_income && r.eps_diluted && Math.abs(r.eps_diluted) > 0.01) {
    r.shares_diluted = Math.abs(r.net_income / r.eps_diluted);
  }

  return r;
}

function extractFromXBRL(xbrl, filingDate, is10K) {
  var facts = xbrl.facts || {};
  var gaap = facts["us-gaap"] || {};
  var dei = facts["dei"] || {};
  var r = {};

  // Filing year from date
  var filingYear = parseInt(filingDate.substring(0, 4));

  // Helper: get most recent annual or quarterly value for a concept
  function getVal(conceptNames, preferAnnual) {
    for (var ci = 0; ci < conceptNames.length; ci++) {
      var concept = gaap[conceptNames[ci]] || dei[conceptNames[ci]];
      if (!concept) continue;
      var units = concept.units || {};
      var values = units.USD || units.shares || units["USD/shares"] || units.pure || [];
      if (!values.length) continue;

      // Filter to recent filings and sort by end date
      var recent = [];
      for (var vi = 0; vi < values.length; vi++) {
        var v = values[vi];
        if (!v.end) continue;
        var endYear = parseInt(v.end.substring(0, 4));
        if (endYear < filingYear - 1) continue; // only recent
        // For annual: want ~12 month periods (or instant for BS)
        // For quarterly: want ~3 month periods
        var startDate = v.start;
        var months = 0;
        if (startDate) {
          var sd = new Date(startDate), ed = new Date(v.end);
          months = Math.round((ed - sd) / (30.44 * 24 * 60 * 60 * 1000));
        }
        recent.push({val: v.val, end: v.end, start: v.start || "", months: months, filed: v.filed || "", form: v.form || ""});
      }

      // Sort by end date descending
      recent.sort(function(a, b) { return b.end.localeCompare(a.end); });

      if (preferAnnual) {
        // Want ~12 month period (10-12 months) or instant (BS items)
        for (var ri = 0; ri < recent.length; ri++) {
          if (recent[ri].months >= 10 && recent[ri].months <= 14) return recent[ri].val;
          if (recent[ri].months === 0 && !recent[ri].start) return recent[ri].val; // instant (BS)
        }
        // Fallback: just take most recent
        if (recent.length) return recent[0].val;
      } else {
        // Most recent value
        if (recent.length) return recent[0].val;
      }
    }
    return null;
  }

  // Helper for balance sheet items (instant, no period)
  function getInstant(conceptNames) {
    for (var ci = 0; ci < conceptNames.length; ci++) {
      var concept = gaap[conceptNames[ci]] || dei[conceptNames[ci]];
      if (!concept) continue;
      var units = concept.units || {};
      var values = units.USD || [];
      if (!values.length) continue;
      var recent = [];
      for (var vi = 0; vi < values.length; vi++) {
        var v = values[vi];
        if (!v.end) continue;
        if (!v.start || v.start === "") recent.push({val: v.val, end: v.end}); // instant
        else {
          var sd2 = new Date(v.start), ed2 = new Date(v.end);
          var m2 = Math.round((ed2 - sd2) / (30.44 * 24 * 60 * 60 * 1000));
          if (m2 < 2) recent.push({val: v.val, end: v.end}); // near-instant
        }
      }
      recent.sort(function(a, b) { return b.end.localeCompare(a.end); });
      if (recent.length) return recent[0].val;
    }
    return null;
  }

  // Income statement (annual preferred)
  var rev = getVal(["RevenueFromContractWithCustomerExcludingAssessedTax", "Revenues", "RevenueFromContractWithCustomerIncludingAssessedTax", "SalesRevenueNet", "RevenueFromContractWithCustomerExcludingAssessedTaxNew", "InterestIncomeExpenseNet", "TotalRevenuesAndOtherIncome", "NetRevenuesIncludingNetInterestIncome"], true);
  if (rev) r.revenue = rev;

  var ni = getVal(["NetIncomeLoss", "ProfitLoss", "NetIncomeLossAvailableToCommonStockholdersBasic"], true);
  if (ni) r.net_income = ni;

  var oi = getVal(["OperatingIncomeLoss", "IncomeLossFromContinuingOperationsBeforeIncomeTaxes"], true);
  if (oi) r.operating_income = oi;

  var gp = getVal(["GrossProfit"], true);
  if (gp) r.gross_profit = gp;

  // Cash flow (annual)
  var ocf = getVal(["NetCashProvidedByOperatingActivities", "CashCashEquivalentsRestrictedCashAndRestrictedCashEquivalentsPeriodIncreaseDecreaseIncludingExchangeRateEffect"], true);
  if (ocf) r.operating_cf = ocf;

  var capex = getVal(["PaymentsToAcquirePropertyPlantAndEquipment", "PaymentsToAcquireProductiveAssets", "CapitalExpendituresIncurredButNotYetPaid"], true);
  if (capex) r.capex = Math.abs(capex);

  var da = getVal(["DepreciationDepletionAndAmortization", "DepreciationAndAmortization", "Depreciation"], true);
  if (da) r.depreciation = da;

  // Balance sheet (instant values)
  var cash = getInstant(["CashAndCashEquivalentsAtCarryingValue", "CashCashEquivalentsAndShortTermInvestments", "Cash"]);
  if (cash) r.cash = cash;

  var debt = getInstant(["LongTermDebt", "LongTermDebtNoncurrent", "LongTermDebtAndCapitalLeaseObligations"]);
  if (debt) r.long_term_debt = debt;

  var eq = getInstant(["StockholdersEquity", "StockholdersEquityIncludingPortionAttributableToNoncontrollingInterest"]);
  if (eq) r.stockholders_equity = eq;

  var ta = getInstant(["Assets"]);
  if (ta) r.total_assets = ta;

  var tl = getInstant(["Liabilities"]);
  if (tl) r.total_liabilities = tl;

  // Per share
  var eps = getVal(["EarningsPerShareDiluted"], true);
  if (eps) r.eps_diluted = eps;

  // Shares
  var shares = getVal(["WeightedAverageNumberOfDilutedSharesOutstanding", "CommonStockSharesOutstanding", "EntityCommonStockSharesOutstanding"], true);
  if (!shares) shares = getInstant(["CommonStockSharesOutstanding", "EntityCommonStockSharesOutstanding"]);
  if (shares) r.shares_diluted = shares;

  // Derived
  if (r.operating_cf && r.capex) r.fcf = r.operating_cf - r.capex;
  else if (r.operating_cf) { r.capex = 0; r.fcf = r.operating_cf; }

  // Prior year revenue for trailing growth
  // Look for revenue from ~12 months before the most recent
  if (r.revenue) {
    var revConcepts = ["RevenueFromContractWithCustomerExcludingAssessedTax", "Revenues", "RevenueFromContractWithCustomerIncludingAssessedTax", "SalesRevenueNet", "InterestIncomeExpenseNet"];
    for (var ci = 0; ci < revConcepts.length; ci++) {
      var concept = gaap[revConcepts[ci]];
      if (!concept) continue;
      var values = (concept.units || {}).USD || [];
      var annuals = [];
      for (var vi = 0; vi < values.length; vi++) {
        var v = values[vi];
        if (!v.start || !v.end) continue;
        var sd3 = new Date(v.start), ed3 = new Date(v.end);
        var m3 = Math.round((ed3 - sd3) / (30.44 * 24 * 60 * 60 * 1000));
        if (m3 >= 10 && m3 <= 14) annuals.push({val: v.val, end: v.end});
      }
      annuals.sort(function(a, b) { return b.end.localeCompare(a.end); });
      if (annuals.length >= 2) {
        r.revenue_prior = annuals[1].val;
        break;
      }
    }
  }

  return r;
}

function detectSectorFromSIC(sic, sicDesc, companyName) {
  var s = (sic + " " + sicDesc + " " + companyName).toLowerCase();
  if (sic >= "6020" && sic <= "6099" || s.indexOf("bank") >= 0 || s.indexOf("depository") >= 0) return ["bank", "high"];
  if (sic >= "6311" && sic <= "6399" || s.indexOf("insurance") >= 0) return ["insurance", "high"];
  if (sic >= "4911" && sic <= "4941" || s.indexOf("electric") >= 0 && s.indexOf("utility") >= 0) return ["utility", "high"];
  if (sic >= "1311" && sic <= "1389" || s.indexOf("crude") >= 0 || s.indexOf("petroleum") >= 0) return ["ep", "high"];
  if (sic >= "4600" && sic <= "4699" || s.indexOf("pipeline") >= 0) return ["midstream", "medium"];
  if (sic >= "2830" && sic <= "2836" || s.indexOf("pharmaceutical") >= 0 || s.indexOf("biotech") >= 0) return ["pharma", "high"];
  if (sic >= "4800" && sic <= "4899" || s.indexOf("telecom") >= 0 || s.indexOf("wireless") >= 0) return ["telecom", "medium"];
  if (sic === "7372" || sic === "7371" || s.indexOf("software") >= 0 || s.indexOf("saas") >= 0) return ["saas_tech", "medium"];
  if (sic === "7374" || s.indexOf("data process") >= 0 || s.indexOf("cloud") >= 0 || s.indexOf("amazon") >= 0 || s.indexOf("alphabet") >= 0 || s.indexOf("microsoft") >= 0 || s.indexOf("meta platform") >= 0) return ["hyperscaler", "medium"];
  if (sic >= "6150" && sic <= "6199" || s.indexOf("payment") >= 0 || s.indexOf("fintech") >= 0 || s.indexOf("visa") >= 0 || s.indexOf("mastercard") >= 0) return ["fintech", "medium"];
  if (sic >= "5200" && sic <= "5999" || s.indexOf("retail") >= 0 || s.indexOf("store") >= 0) return ["consumer", "medium"];
  if (sic >= "3500" && sic <= "3699" || sic >= "3700" && sic <= "3799" || s.indexOf("semiconductor") >= 0) return ["industrial", "medium"];
  return ["general", "low"];
}

async function fetchMarket(ticker) {
  log("Fetching market data...", "info");
  var price = 0, shares = 0, beta = null, name = ticker;
  try {
    var r = await proxyFetch("https://query1.finance.yahoo.com/v7/finance/quote?symbols=" + ticker);
    var d = await r.json(); var q = ((d.quoteResponse || {}).result || [])[0] || {};
    price = q.regularMarketPrice || 0; shares = q.sharesOutstanding || 0;
    name = q.shortName || q.longName || ticker;
    if (!shares && q.marketCap && price) shares = q.marketCap / price;
  } catch(e) {}
  try {
    var r2 = await proxyFetch("https://query2.finance.yahoo.com/v10/finance/quoteSummary/" + ticker + "?modules=price,defaultKeyStatistics");
    var d2 = await r2.json(); var mods = ((d2.quoteSummary || {}).result || [])[0] || {};
    var pm = mods.price || {}, ks = mods.defaultKeyStatistics || {};
    if (!price) price = ((pm.regularMarketPrice || {}).raw) || 0;
    if (!shares) shares = ((ks.sharesOutstanding || {}).raw) || ((pm.sharesOutstanding || {}).raw) || 0;
    if (!shares && price) { var mc = ((pm.marketCap || {}).raw) || 0; if (mc) shares = mc / price; }
    beta = ((ks.beta || {}).raw) || beta;
  } catch(e) {}
  if (!price) { try {
    var r3 = await proxyFetch("https://query1.finance.yahoo.com/v8/finance/chart/" + ticker + "?range=1d&interval=1d");
    var d3 = await r3.json(); price = ((((d3.chart || {}).result || [])[0] || {}).meta || {}).regularMarketPrice || 0;
  } catch(e) {} }
  if (price > 0) { document.getElementById("price").value = price.toFixed(2); log(name + " $" + price.toFixed(2), "ok"); }
  else log("Price fetch failed - enter manually", "warn");
  if (shares > 0) { document.getElementById("shares").value = (shares / 1e6).toFixed(1); log("Shares: " + (shares / 1e6).toFixed(1) + "M", "ok"); }
  else if (currentFins && currentFins.shares_diluted) { document.getElementById("shares").value = (currentFins.shares_diluted / 1e6).toFixed(1); log("Shares from filing: " + (currentFins.shares_diluted / 1e6).toFixed(1) + "M", "info"); }
  else log("Shares not found - enter manually", "warn");
  if (beta) log("Beta=" + beta.toFixed(2), "info");
}

// â•â•â• FILE & CONTENT â•â•â•
function handleFile(e) {
  var f = e.target.files[0]; if (!f) return;
  var reader = new FileReader();
  reader.onload = function(ev) { loadContent(ev.target.result, f.name); };
  reader.readAsText(f);
}

function loadContent(content, filename) {
  try {
    var result = parseHTMLFiling(content, filename);
    var parsed = result[0];
    currentFins = parsed;
    var fields = Object.keys(parsed).filter(function(k) { return k.charAt(0) !== "_"; }).length;
    document.getElementById("parseStatus").className = "st ok";
    document.getElementById("parseStatus").textContent = "\u2713 " + parsed._form + " | " + (SECTOR_NAMES[parsed._sector] || "General") + " | " + fields + " fields | " + parsed._tables + " tables";
    document.getElementById("inputsCard").className = "card";
    if (parsed.shares_diluted && !document.getElementById("shares").value)
      document.getElementById("shares").value = (parsed.shares_diluted / 1e6).toFixed(1);
    document.getElementById("sector").value = "auto";
    log("Parsed: " + parsed._form + " | " + (SECTOR_NAMES[parsed._sector] || "General") + " (" + parsed._sector_confidence + ") | " + fields + " fields", "ok");
  } catch(e) {
    document.getElementById("parseStatus").className = "st err";
    document.getElementById("parseStatus").textContent = "Parse error: " + e.message;
    log("Parse error: " + e.message, "err");
  }
}

function renderRecents() {
  var el = document.getElementById("recents"); var h = "";
  for (var i = 0; i < recents.length; i++)
    h += '<div class="chip" onclick="document.getElementById(\'ticker\').value=\'' + recents[i] + '\';pullFiling()">' + recents[i] + '</div>';
  el.innerHTML = h;
}
function log(msg, cls) {
  var el = document.getElementById("log");
  var colors = {ok:"#00e676",err:"#ff4081",info:"#7c4dff",warn:"#fdd835"};
  var t = new Date().toTimeString().slice(0, 8);
  el.innerHTML += '<span style="color:' + (colors[cls] || "#556") + '">' + t + "  " + msg + "</span>\n";
  el.scrollTop = el.scrollHeight;
}

// â•â•â• UI â•â•â•
function runDCFUI() {
  if (!currentFins) return;
  try {
  var p = parseFloat(document.getElementById("price").value);
  var s = parseFloat(document.getElementById("shares").value);
  if (!p || !s || p <= 0 || s <= 0) { document.getElementById("parseStatus").className = "st err"; document.getElementById("parseStatus").textContent = "Enter price and shares"; return; }
  var secVal = document.getElementById("sector").value;
  var sec = secVal === "auto" ? (currentFins._sector || "general") : secVal;
  var r = runDcf(currentFins, p, s, sec);
  if (r.error) { document.getElementById("parseStatus").className = "st err"; document.getElementById("parseStatus").textContent = r.error; return; }
  currentResult = r;
  var vc = verdictColor(r.verdict);
  document.getElementById("verdictBanner").style.background = vc + "08";
  document.getElementById("verdictBanner").style.border = "1px solid " + vc + "33";
  document.getElementById("verdictText").textContent = r.verdict;
  document.getElementById("verdictText").style.color = vc;
  document.getElementById("fvVal").textContent = "$" + r.pw_fv.toFixed(2);
  document.getElementById("priceVal").textContent = "$" + p.toFixed(2);
  document.getElementById("upVal").textContent = (r.pw_up > 0 ? "+" : "") + r.pw_up.toFixed(1) + "%";
  document.getElementById("upVal").style.color = r.pw_up > 0 ? "#00e676" : "#ff5252";
  document.getElementById("bbmFlag").className = r.is_buyback_machine ? "" : "hide";
  
  // Summary tab
  var sh = "";
  sh += mkRow("WACC", pct(r.wacc));
  sh += mkRow("Trailing Rev Growth", r.trailing_growth != null ? pct(r.trailing_growth) : "\u2014", r.trailing_growth > 0 ? "#00e676" : "#ff5252");
  sh += mkRow("Implied FCF CAGR", r.implied_fcf_growth != null ? pct(r.implied_fcf_growth) : ">80%", r.implied_fcf_growth > 0.25 ? "#fdd835" : "#66bb6a");
  sh += mkRow("Implied Rev CAGR", r.implied_rev_growth != null ? pct(r.implied_rev_growth) : ">80%");
  var inp = r.inputs || {};
  if (inp.capex_method && inp.capex_method !== "\u2014") sh += mkRow("CapEx Model", inp.capex_method, "#556");
  if (r.sbc_haircut > 0) sh += mkRow("SBC Haircut", fmt(r.sbc_haircut), "#fdd835");
  sh += '<div style="font-size:10px;color:#445;margin-top:8px">Sector: ' + (SECTOR_NAMES[sec] || sec) + ' | ' + currentFins._form + '</div>';
  for (var fi = 0; fi < (r.sanity_flags || []).length; fi++) sh += '<div class="flag">\u26A0 ' + r.sanity_flags[fi] + '</div>';
  document.getElementById("tab-summary").innerHTML = sh;
  
  // Scenarios tab
  var sc = "";
  for (var si = 0; si < r.scenarios.length; si++) {
    var ss = r.scenarios[si];
    var uc = ss.upside > 0 ? "#00e676" : ss.upside > -10 ? "#fdd835" : "#ff5252";
    sc += '<div class="sr"><div><div style="font-size:12px">' + ss.name + '</div><div style="font-size:10px;color:#556">' + Math.round(ss.prob * 100) + '% weight</div></div><div style="text-align:right"><div style="font-size:13px;font-weight:600">$' + ss.fv.toFixed(2) + '</div><div style="font-size:11px;color:' + uc + '">' + (ss.upside > 0 ? "+" : "") + ss.upside.toFixed(1) + '%</div></div></div>';
  }
  document.getElementById("tab-scenarios").innerHTML = sc;
  
  // Financials tab
  var fi2 = "";
  var items = [["Revenue",currentFins.revenue],["Net Income",currentFins.net_income],["Op Income",currentFins.operating_income],["Op CF",currentFins.operating_cf],["CapEx",currentFins.capex],["D&A",currentFins.depreciation],["FCF (reported)",inp.fcf_reported],["FCF (used)",inp.fcf],["EBITDA",inp.ebitda],["Cash",currentFins.cash],["LT Debt",currentFins.long_term_debt],["Equity",currentFins.stockholders_equity],["EPS",currentFins.eps_diluted]];
  for (var ii = 0; ii < items.length; ii++) {
    if (items[ii][1] == null) continue;
    fi2 += mkRow(items[ii][0], items[ii][0] === "EPS" ? "$" + items[ii][1].toFixed(2) : fmt(items[ii][1]));
  }
  fi2 += '<div style="margin-top:8px;font-size:10px;color:#445">Scale: ' + (currentFins._scale || 1000).toLocaleString() + ' | Tables: ' + currentFins._tables + ' | Shares: ' + s.toFixed(1) + 'M</div>';
  document.getElementById("tab-financials").innerHTML = fi2;
  document.getElementById("results").className = "";
  showTab("summary", document.querySelector(".tabs button"));
  } catch(e) { log("DCF Error: " + e.message, "err"); console.error(e); }
}

function mkRow(k, v, c) { return '<div class="dr"><span class="k">' + k + '</span><span class="v" style="color:' + (c || "var(--text)") + '">' + v + '</span></div>'; }
function showTab(name, btn) {
  var tabs = ["summary", "scenarios", "financials"];
  for (var i = 0; i < tabs.length; i++) document.getElementById("tab-" + tabs[i]).className = tabs[i] === name ? "card" : "card hide";
  var btns = document.querySelectorAll(".tabs button");
  for (var i = 0; i < btns.length; i++) btns[i].className = btns[i] === btn ? "act" : "";
}
// verdictColor already defined above

</script>
</body>
</html>
